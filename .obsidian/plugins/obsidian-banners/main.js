/*
- THIS IS A GENERATED/BUNDLED FILE BY ROLLUP -
Please visit the repository linked to view the source code:
https://github.com/noatpad/obsidian-banners
*/
'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var assertString_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertString;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;

  if (!isString) {
    var invalidType = _typeof(input);

    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;
    throw new TypeError("Expected a string but received a ".concat(invalidType));
  }
}

module.exports = exports.default;
module.exports.default = exports.default;
});

var merge_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;

function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : undefined;

  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }

  return obj;
}

module.exports = exports.default;
module.exports.default = exports.default;
});

var isFQDN_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isFQDN;

var _assertString = _interopRequireDefault(assertString_1);

var _merge = _interopRequireDefault(merge_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_numeric_tld: false
};

function isFQDN(str, options) {
  (0, _assertString.default)(str);
  options = (0, _merge.default)(options, default_fqdn_options);
  /* Remove the optional trailing dot before checking validity */

  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }

  var parts = str.split('.');
  var tld = parts[parts.length - 1];

  if (options.require_tld) {
    // disallow fqdns without tld
    if (parts.length < 2) {
      return false;
    }

    if (!/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    } // disallow spaces && special characers


    if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20\u00A9\uFFFD]/.test(tld)) {
      return false;
    }
  } // reject numeric TLDs


  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
    return false;
  }

  return parts.every(function (part) {
    if (part.length > 63) {
      return false;
    }

    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    } // disallow full-width chars


    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    } // disallow parts starting or ending with hyphen


    if (/^-|-$/.test(part)) {
      return false;
    }

    if (!options.allow_underscores && /_/.test(part)) {
      return false;
    }

    return true;
  });
}

module.exports = exports.default;
module.exports.default = exports.default;
});

var isIP_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isIP;

var _assertString = _interopRequireDefault(assertString_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
11.3.  Examples

   The following addresses

             fe80::1234 (on the 1st link of the node)
             ff02::5678 (on the 5th link of the node)
             ff08::9abc (on the 10th organization of the node)

   would be represented as follows:

             fe80::1234%1
             ff02::5678%5
             ff08::9abc%10

   (Here we assume a natural translation from a zone index to the
   <zone_id> part, where the Nth zone of any scope is translated into
   "N".)

   If we use interface names as <zone_id>, those addresses could also be
   represented as follows:

            fe80::1234%ne0
            ff02::5678%pvc1.3
            ff08::9abc%interface10

   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
   to the 5th link, and "interface10" belongs to the 10th organization.
 * * */
var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z-.:]{1,})?$');

function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString.default)(str);
  version = String(version);

  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  }

  if (version === '4') {
    if (!IPv4AddressRegExp.test(str)) {
      return false;
    }

    var parts = str.split('.').sort(function (a, b) {
      return a - b;
    });
    return parts[3] <= 255;
  }

  if (version === '6') {
    return !!IPv6AddressRegExp.test(str);
  }

  return false;
}

module.exports = exports.default;
module.exports.default = exports.default;
});

var isURL_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isURL;

var _assertString = _interopRequireDefault(assertString_1);

var _isFQDN = _interopRequireDefault(isFQDN_1);

var _isIP = _interopRequireDefault(isIP_1);

var _merge = _interopRequireDefault(merge_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
options for isURL method

require_protocol - if set as true isURL will return false if protocol is not present in the URL
require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
protocols - valid protocols can be modified with this option
require_host - if set as false isURL will not check if host is present in the URL
require_port - if set as true isURL will check if port is present in the URL
allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)

*/
var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_port: false,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false,
  validate_length: true
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;

function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}

function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];

    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }

  return false;
}

function isURL(url, options) {
  (0, _assertString.default)(url);

  if (!url || /[\s<>]/.test(url)) {
    return false;
  }

  if (url.indexOf('mailto:') === 0) {
    return false;
  }

  options = (0, _merge.default)(options, default_url_options);

  if (options.validate_length && url.length >= 2083) {
    return false;
  }

  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  split = url.split('#');
  url = split.shift();
  split = url.split('?');
  url = split.shift();
  split = url.split('://');

  if (split.length > 1) {
    protocol = split.shift().toLowerCase();

    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.substr(0, 2) === '//') {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }

    split[0] = url.substr(2);
  }

  url = split.join('://');

  if (url === '') {
    return false;
  }

  split = url.split('/');
  url = split.shift();

  if (url === '' && !options.require_host) {
    return true;
  }

  split = url.split('@');

  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }

    if (split[0] === '' || split[0].substr(0, 1) === ':') {
      return false;
    }

    auth = split.shift();

    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }
  }

  hostname = split.join('@');
  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);

  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();

    if (split.length) {
      port_str = split.join(':');
    }
  }

  if (port_str !== null) {
    port = parseInt(port_str, 10);

    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  } else if (options.require_port) {
    return false;
  }

  if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
    return false;
  }

  host = host || ipv6;

  if (options.host_whitelist && !checkHost(host, options.host_whitelist)) {
    return false;
  }

  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }

  return true;
}

module.exports = exports.default;
module.exports.default = exports.default;
});

var isURL = /*@__PURE__*/getDefaultExportFromCjs(isURL_1);

/**
 * The base implementation of `_.clamp` which doesn't coerce arguments.
 *
 * @private
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 */
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== undefined) {
      number = number <= upper ? number : upper;
    }
    if (lower !== undefined) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}

var _baseClamp = baseClamp;

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

var _trimmedEndIndex = trimmedEndIndex;

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

var _baseTrim = baseTrim;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** Detect free variable `global` from Node.js. */

var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
}

var isSymbol_1 = isSymbol;

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol_1(value)) {
    return NAN;
  }
  if (isObject_1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject_1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = _baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var toNumber_1 = toNumber;

/**
 * Clamps `number` within the inclusive `lower` and `upper` bounds.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Number
 * @param {number} number The number to clamp.
 * @param {number} [lower] The lower bound.
 * @param {number} upper The upper bound.
 * @returns {number} Returns the clamped number.
 * @example
 *
 * _.clamp(-10, -5, 5);
 * // => -5
 *
 * _.clamp(10, -5, 5);
 * // => 5
 */
function clamp(number, lower, upper) {
  if (upper === undefined) {
    upper = lower;
    lower = undefined;
  }
  if (upper !== undefined) {
    upper = toNumber_1(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== undefined) {
    lower = toNumber_1(lower);
    lower = lower === lower ? lower : 0;
  }
  return _baseClamp(toNumber_1(number), lower, upper);
}

var clamp_1 = clamp;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _templateObject = _taggedTemplateLiteral(['', ''], ['', '']);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class TemplateTag
 * @classdesc Consumes a pipeline of composable transformer plugins and produces a template tag.
 */
var TemplateTag = function () {
  /**
   * constructs a template tag
   * @constructs TemplateTag
   * @param  {...Object} [...transformers] - an array or arguments list of transformers
   * @return {Function}                    - a template tag
   */
  function TemplateTag() {
    var _this = this;

    for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {
      transformers[_key] = arguments[_key];
    }

    _classCallCheck(this, TemplateTag);

    this.tag = function (strings) {
      for (var _len2 = arguments.length, expressions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        expressions[_key2 - 1] = arguments[_key2];
      }

      if (typeof strings === 'function') {
        // if the first argument passed is a function, assume it is a template tag and return
        // an intermediary tag that processes the template using the aforementioned tag, passing the
        // result to our tag
        return _this.interimTag.bind(_this, strings);
      }

      if (typeof strings === 'string') {
        // if the first argument passed is a string, just transform it
        return _this.transformEndResult(strings);
      }

      // else, return a transformed end result of processing the template with our tag
      strings = strings.map(_this.transformString.bind(_this));
      return _this.transformEndResult(strings.reduce(_this.processSubstitutions.bind(_this, expressions)));
    };

    // if first argument is an array, extrude it as a list of transformers
    if (transformers.length > 0 && Array.isArray(transformers[0])) {
      transformers = transformers[0];
    }

    // if any transformers are functions, this means they are not initiated - automatically initiate them
    this.transformers = transformers.map(function (transformer) {
      return typeof transformer === 'function' ? transformer() : transformer;
    });

    // return an ES2015 template tag
    return this.tag;
  }

  /**
   * Applies all transformers to a template literal tagged with this method.
   * If a function is passed as the first argument, assumes the function is a template tag
   * and applies it to the template, returning a template tag.
   * @param  {(Function|String|Array<String>)} strings        - Either a template tag or an array containing template strings separated by identifier
   * @param  {...*}                            ...expressions - Optional list of substitution values.
   * @return {(String|Function)}                              - Either an intermediary tag function or the results of processing the template.
   */


  _createClass(TemplateTag, [{
    key: 'interimTag',


    /**
     * An intermediary template tag that receives a template tag and passes the result of calling the template with the received
     * template tag to our own template tag.
     * @param  {Function}        nextTag          - the received template tag
     * @param  {Array<String>}   template         - the template to process
     * @param  {...*}            ...substitutions - `substitutions` is an array of all substitutions in the template
     * @return {*}                                - the final processed value
     */
    value: function interimTag(previousTag, template) {
      for (var _len3 = arguments.length, substitutions = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        substitutions[_key3 - 2] = arguments[_key3];
      }

      return this.tag(_templateObject, previousTag.apply(undefined, [template].concat(substitutions)));
    }

    /**
     * Performs bulk processing on the tagged template, transforming each substitution and then
     * concatenating the resulting values into a string.
     * @param  {Array<*>} substitutions - an array of all remaining substitutions present in this template
     * @param  {String}   resultSoFar   - this iteration's result string so far
     * @param  {String}   remainingPart - the template chunk after the current substitution
     * @return {String}                 - the result of joining this iteration's processed substitution with the result
     */

  }, {
    key: 'processSubstitutions',
    value: function processSubstitutions(substitutions, resultSoFar, remainingPart) {
      var substitution = this.transformSubstitution(substitutions.shift(), resultSoFar);
      return ''.concat(resultSoFar, substitution, remainingPart);
    }

    /**
     * Iterate through each transformer, applying the transformer's `onString` method to the template
     * strings before all substitutions are processed.
     * @param {String}  str - The input string
     * @return {String}     - The final results of processing each transformer
     */

  }, {
    key: 'transformString',
    value: function transformString(str) {
      var cb = function cb(res, transform) {
        return transform.onString ? transform.onString(res) : res;
      };
      return this.transformers.reduce(cb, str);
    }

    /**
     * When a substitution is encountered, iterates through each transformer and applies the transformer's
     * `onSubstitution` method to the substitution.
     * @param  {*}      substitution - The current substitution
     * @param  {String} resultSoFar  - The result up to and excluding this substitution.
     * @return {*}                   - The final result of applying all substitution transformations.
     */

  }, {
    key: 'transformSubstitution',
    value: function transformSubstitution(substitution, resultSoFar) {
      var cb = function cb(res, transform) {
        return transform.onSubstitution ? transform.onSubstitution(res, resultSoFar) : res;
      };
      return this.transformers.reduce(cb, substitution);
    }

    /**
     * Iterates through each transformer, applying the transformer's `onEndResult` method to the
     * template literal after all substitutions have finished processing.
     * @param  {String} endResult - The processed template, just before it is returned from the tag
     * @return {String}           - The final results of processing each transformer
     */

  }, {
    key: 'transformEndResult',
    value: function transformEndResult(endResult) {
      var cb = function cb(res, transform) {
        return transform.onEndResult ? transform.onEndResult(res) : res;
      };
      return this.transformers.reduce(cb, endResult);
    }
  }]);

  return TemplateTag;
}();

/**
 * TemplateTag transformer that trims whitespace on the end result of a tagged template
 * @param  {String} side = '' - The side of the string to trim. Can be 'start' or 'end' (alternatively 'left' or 'right')
 * @return {Object}           - a TemplateTag transformer
 */
var trimResultTransformer = function trimResultTransformer() {
  var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    onEndResult: function onEndResult(endResult) {
      if (side === '') {
        return endResult.trim();
      }

      side = side.toLowerCase();

      if (side === 'start' || side === 'left') {
        return endResult.replace(/^\s*/, '');
      }

      if (side === 'end' || side === 'right') {
        return endResult.replace(/\s*$/, '');
      }

      throw new Error('Side not supported: ' + side);
    }
  };
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * strips indentation from a template literal
 * @param  {String} type = 'initial' - whether to remove all indentation or just leading indentation. can be 'all' or 'initial'
 * @return {Object}                  - a TemplateTag transformer
 */
var stripIndentTransformer = function stripIndentTransformer() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'initial';
  return {
    onEndResult: function onEndResult(endResult) {
      if (type === 'initial') {
        // remove the shortest leading indentation from each line
        var match = endResult.match(/^[^\S\n]*(?=\S)/gm);
        var indent = match && Math.min.apply(Math, _toConsumableArray(match.map(function (el) {
          return el.length;
        })));
        if (indent) {
          var regexp = new RegExp('^.{' + indent + '}', 'gm');
          return endResult.replace(regexp, '');
        }
        return endResult;
      }
      if (type === 'all') {
        // remove all indentation from each line
        return endResult.replace(/^[^\S\n]+/gm, '');
      }
      throw new Error('Unknown type: ' + type);
    }
  };
};

/**
 * Replaces tabs, newlines and spaces with the chosen value when they occur in sequences
 * @param  {(String|RegExp)} replaceWhat - the value or pattern that should be replaced
 * @param  {*}               replaceWith - the replacement value
 * @return {Object}                      - a TemplateTag transformer
 */
var replaceResultTransformer = function replaceResultTransformer(replaceWhat, replaceWith) {
  return {
    onEndResult: function onEndResult(endResult) {
      if (replaceWhat == null || replaceWith == null) {
        throw new Error('replaceResultTransformer requires at least 2 arguments.');
      }
      return endResult.replace(replaceWhat, replaceWith);
    }
  };
};

var replaceSubstitutionTransformer = function replaceSubstitutionTransformer(replaceWhat, replaceWith) {
  return {
    onSubstitution: function onSubstitution(substitution, resultSoFar) {
      if (replaceWhat == null || replaceWith == null) {
        throw new Error('replaceSubstitutionTransformer requires at least 2 arguments.');
      }

      // Do not touch if null or undefined
      if (substitution == null) {
        return substitution;
      } else {
        return substitution.toString().replace(replaceWhat, replaceWith);
      }
    }
  };
};

var defaults = {
  separator: '',
  conjunction: '',
  serial: false
};

/**
 * Converts an array substitution to a string containing a list
 * @param  {String} [opts.separator = ''] - the character that separates each item
 * @param  {String} [opts.conjunction = '']  - replace the last separator with this
 * @param  {Boolean} [opts.serial = false] - include the separator before the conjunction? (Oxford comma use-case)
 *
 * @return {Object}                     - a TemplateTag transformer
 */
var inlineArrayTransformer = function inlineArrayTransformer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaults;
  return {
    onSubstitution: function onSubstitution(substitution, resultSoFar) {
      // only operate on arrays
      if (Array.isArray(substitution)) {
        var arrayLength = substitution.length;
        var separator = opts.separator;
        var conjunction = opts.conjunction;
        var serial = opts.serial;
        // join each item in the array into a string where each item is separated by separator
        // be sure to maintain indentation
        var indent = resultSoFar.match(/(\n?[^\S\n]+)$/);
        if (indent) {
          substitution = substitution.join(separator + indent[1]);
        } else {
          substitution = substitution.join(separator + ' ');
        }
        // if conjunction is set, replace the last separator with conjunction, but only if there is more than one substitution
        if (conjunction && arrayLength > 1) {
          var separatorIndex = substitution.lastIndexOf(separator);
          substitution = substitution.slice(0, separatorIndex) + (serial ? separator : '') + ' ' + conjunction + substitution.slice(separatorIndex + 1);
        }
      }
      return substitution;
    }
  };
};

var splitStringTransformer = function splitStringTransformer(splitBy) {
  return {
    onSubstitution: function onSubstitution(substitution, resultSoFar) {
      if (splitBy != null && typeof splitBy === 'string') {
        if (typeof substitution === 'string' && substitution.includes(splitBy)) {
          substitution = substitution.split(splitBy);
        }
      } else {
        throw new Error('You need to specify a string character to split by.');
      }
      return substitution;
    }
  };
};

var isValidValue = function isValidValue(x) {
  return x != null && !Number.isNaN(x) && typeof x !== 'boolean';
};

var removeNonPrintingValuesTransformer = function removeNonPrintingValuesTransformer() {
  return {
    onSubstitution: function onSubstitution(substitution) {
      if (Array.isArray(substitution)) {
        return substitution.filter(isValidValue);
      }
      if (isValidValue(substitution)) {
        return substitution;
      }
      return '';
    }
  };
};

new TemplateTag(inlineArrayTransformer({ separator: ',' }), stripIndentTransformer, trimResultTransformer);

new TemplateTag(inlineArrayTransformer({ separator: ',', conjunction: 'and' }), stripIndentTransformer, trimResultTransformer);

new TemplateTag(inlineArrayTransformer({ separator: ',', conjunction: 'or' }), stripIndentTransformer, trimResultTransformer);

var html = new TemplateTag(splitStringTransformer('\n'), removeNonPrintingValuesTransformer, inlineArrayTransformer, stripIndentTransformer, trimResultTransformer);

new TemplateTag(splitStringTransformer('\n'), inlineArrayTransformer, stripIndentTransformer, trimResultTransformer, replaceSubstitutionTransformer(/&/g, '&amp;'), replaceSubstitutionTransformer(/</g, '&lt;'), replaceSubstitutionTransformer(/>/g, '&gt;'), replaceSubstitutionTransformer(/"/g, '&quot;'), replaceSubstitutionTransformer(/'/g, '&#x27;'), replaceSubstitutionTransformer(/`/g, '&#x60;'));

new TemplateTag(replaceResultTransformer(/(?:\n(?:\s*))+/g, ' '), trimResultTransformer);

new TemplateTag(replaceResultTransformer(/(?:\n\s*)/g, ''), trimResultTransformer);

new TemplateTag(inlineArrayTransformer({ separator: ',' }), replaceResultTransformer(/(?:\s+)/g, ' '), trimResultTransformer);

new TemplateTag(inlineArrayTransformer({ separator: ',', conjunction: 'or' }), replaceResultTransformer(/(?:\s+)/g, ' '), trimResultTransformer);

new TemplateTag(inlineArrayTransformer({ separator: ',', conjunction: 'and' }), replaceResultTransformer(/(?:\s+)/g, ' '), trimResultTransformer);

new TemplateTag(inlineArrayTransformer, stripIndentTransformer, trimResultTransformer);

new TemplateTag(inlineArrayTransformer, replaceResultTransformer(/(?:\s+)/g, ' '), trimResultTransformer);

new TemplateTag(stripIndentTransformer, trimResultTransformer);

var stripIndents = new TemplateTag(stripIndentTransformer('all'), trimResultTransformer);

class Banner extends obsidian.MarkdownRenderChild {
    constructor(plugin, el, wrapper, ctx, isEmbed) {
        super(el);
        this.wrapper = wrapper;
        this.plugin = plugin;
        this.metaManager = plugin.metaManager;
        this.vault = plugin.vault;
        this.ctx = ctx;
        this.isEmbed = isEmbed;
        this.isDragging = false;
        this.prevPos = null;
    }
    // Prepare and render banner
    onload() {
        const { allowMobileDrag, style } = this.plugin.settings;
        const { containerEl: contentEl, frontmatter: { banner: src, banner_x = 0.5, banner_y = 0.5 } } = this.ctx;
        this.wrapper.addClass('obsidian-banner-wrapper');
        this.containerEl.addClasses(['obsidian-banner', style]);
        const messageBox = document.createElement('div');
        messageBox.className = 'banner-message';
        messageBox.innerHTML = html `
      <div class="spinner">
        <div class="bounce1"></div>
        <div class="bounce2"></div>
        <div class="bounce3"></div>
      </div>
    `;
        const img = document.createElement('img');
        img.className = 'banner-image full-width';
        img.style.objectPosition = `${banner_x * 100}% ${banner_y * 100}%`;
        img.draggable = false;
        img.onload = () => {
            this.wrapper.addClass('loaded');
        };
        img.onerror = () => {
            messageBox.innerHTML = '<p>Error loading banner image! Is the <code>banner</code> field valid?</p>';
            this.wrapper.addClass('error');
        };
        // Only enable banner drag adjustment in non-embed views
        if (!this.isEmbed) {
            img.onmousedown = (e) => this.handleDragStart(e);
            img.onmousemove = (e) => this.handleDragMove(e);
            contentEl.parentElement.onmouseup = () => this.handleDragEnd(img);
            if (allowMobileDrag) {
                img.ontouchstart = (e) => this.handleDragStart(e);
                img.ontouchmove = (e) => this.handleDragMove(e);
                contentEl.parentElement.ontouchend = () => this.handleDragEnd(img);
            }
        }
        img.src = this.parseSource(src);
        this.containerEl.append(messageBox, img);
        this.wrapper.prepend(this.containerEl);
    }
    handleDragStart(e) {
        this.prevPos = this.getMousePos(e, this.containerEl);
        this.isDragging = true;
    }
    handleDragMove(e) {
        const img = e.target;
        const wrapper = img.parentElement;
        // Only continue if dragging
        if (!this.isDragging) {
            return;
        }
        // Get delta of mouse drag
        const currentPos = this.getMousePos(e, this.containerEl);
        const delta = {
            x: (currentPos.x - this.prevPos.x) / wrapper.clientWidth * 100,
            y: (currentPos.y - this.prevPos.y) / wrapper.clientHeight * 100
        };
        this.prevPos = currentPos;
        // Only adjust the relevant scroll axis
        const [x, y] = img.style.objectPosition
            .split(' ')
            .map(n => parseFloat(n));
        if ((img.naturalHeight / img.naturalWidth) >= (wrapper.clientHeight / wrapper.clientWidth)) {
            const newY = clamp_1(y - delta.y, 0, 100);
            img.style.objectPosition = `${x}% ${newY}%`;
        }
        else {
            const newX = clamp_1(x - delta.x, 0, 100);
            img.style.objectPosition = `${newX}% ${y}%`;
        }
    }
    handleDragEnd(img) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sourcePath } = this.ctx;
            // Only continue when finishing drag
            if (!this.isDragging) {
                return;
            }
            this.isDragging = false;
            // Update banner data
            const [x, y] = img.style.objectPosition
                .split(' ')
                .map(n => Math.round(parseFloat(n) * 1000) / 100000);
            yield this.metaManager.upsertBannerData(sourcePath, { banner_x: x, banner_y: y });
        });
    }
    // Helper to get the URL path to the image file
    parseSource(src) {
        const file = this.vault.getAbstractFileByPath(src);
        return (file instanceof obsidian.TFile) ? this.vault.adapter.getResourcePath(src) : src;
    }
    // Helper to get mouse position
    getMousePos(e, div) {
        const { pageX, pageY } = (e instanceof MouseEvent) ? e : e.targetTouches[0];
        return { x: pageX - div.offsetTop, y: pageY - div.offsetLeft };
    }
}

const DEFAULT_SETTINGS = {
    height: null,
    style: 'solid',
    showInEmbed: true,
    embedHeight: null,
    showPreviewInLocalModal: true,
    localSuggestionsLimit: null,
    bannersFolder: '',
    allowMobileDrag: false
};
const INITIAL_SETTINGS = {
    height: 250,
    embedHeight: 120,
    localSuggestionsLimit: 10,
    bannersFolder: '/'
};
const STYLE_OPTIONS = {
    solid: 'Solid',
    gradient: 'Gradient'
};
class SettingsTab extends obsidian.PluginSettingTab {
    constructor(plugin) {
        super(plugin.app, plugin);
        this.plugin = plugin;
    }
    saveSettings({ rerenderSettings = false, refreshViews = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.plugin.saveData(this.plugin.settings);
            this.plugin.loadStyles();
            if (rerenderSettings) {
                this.display();
            }
            if (refreshViews) {
                this.plugin.refreshViews();
            }
        });
    }
    display() {
        const { containerEl } = this;
        const { height, style, showInEmbed, embedHeight, showPreviewInLocalModal, localSuggestionsLimit, bannersFolder, allowMobileDrag } = this.plugin.settings;
        containerEl.empty();
        this.createHeader("Banners", "A nice, lil' thing to add some presentation to your notes");
        // Banner height
        new obsidian.Setting(containerEl)
            .setName('Banner height')
            .setDesc('Set how big the banner should be in pixels')
            .addText(text => {
            text.inputEl.type = 'number';
            text.setValue(`${height}`);
            text.setPlaceholder(`${INITIAL_SETTINGS.height}`);
            text.onChange((val) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.height = val ? parseInt(val) : null;
                yield this.saveSettings();
            }));
        });
        // Banner style
        new obsidian.Setting(containerEl)
            .setName('Banner style')
            .setDesc('Set a style for all of your banners')
            .addDropdown(dropdown => dropdown
            .addOptions(STYLE_OPTIONS)
            .setValue(style)
            .onChange((val) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.style = val;
            yield this.saveSettings({ refreshViews: true });
        })));
        // Show banner in embed
        new obsidian.Setting(containerEl)
            .setName('Show banner in preview embed')
            .setDesc('Choose whether to display the banner in the page preview embed')
            .addToggle(toggle => toggle
            .setValue(showInEmbed)
            .onChange((val) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.showInEmbed = val;
            yield this.saveSettings({ rerenderSettings: true, refreshViews: true });
        })));
        // Embed banner height
        if (this.plugin.settings.showInEmbed) {
            new obsidian.Setting(containerEl)
                .setName('Embed banner height')
                .setDesc('Set the banner size inside the file preview embed')
                .addText(text => {
                text.inputEl.type = 'number';
                text.setValue(`${embedHeight}`);
                text.setPlaceholder(`${INITIAL_SETTINGS.embedHeight}`);
                text.onChange((val) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.embedHeight = val ? parseInt(val) : null;
                    yield this.saveSettings();
                }));
            });
        }
        this.createHeader('Local Image Modal', 'For the modal that shows when you run the "Add/Change banner with local image" command');
        // Show preview images in local image modal
        new obsidian.Setting(containerEl)
            .setName('Show preview images')
            .setDesc('Enabling this will display a preview of the images suggested')
            .addToggle(toggle => toggle
            .setValue(showPreviewInLocalModal)
            .onChange((val) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.showPreviewInLocalModal = val;
            yield this.saveSettings();
        })));
        // Limit of suggestions in local image modal
        new obsidian.Setting(containerEl)
            .setName('Suggestions limit')
            .setDesc(createFragment(frag => {
            frag.appendText('Show up to this many suggestions when searching through local images.');
            frag.createEl('br');
            frag.createEl('b', { text: 'NOTE: ' });
            frag.appendText('Using a high number while ');
            frag.createEl('span', { text: 'Show preview images ', attr: { style: 'color: var(--text-normal)' } });
            frag.appendText('is on can lead to some slowdowns');
        }))
            .addText(text => {
            text.inputEl.type = 'number';
            text.setValue(`${localSuggestionsLimit}`);
            text.setPlaceholder(`${INITIAL_SETTINGS.localSuggestionsLimit}`);
            text.onChange((val) => __awaiter(this, void 0, void 0, function* () {
                this.plugin.settings.localSuggestionsLimit = val ? parseInt(val) : null;
                yield this.saveSettings();
            }));
        });
        // Search in a specific folder for banners
        new obsidian.Setting(containerEl)
            .setName('Banners folder')
            .setDesc(createFragment(frag => {
            frag.appendText('Select a folder to exclusively search for banner files in.');
            frag.createEl('br');
            frag.appendText('If empty, it will search the entire vault for image files');
        }))
            .addText(text => text
            .setValue(bannersFolder)
            .setPlaceholder(INITIAL_SETTINGS.bannersFolder)
            .onChange((val) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.bannersFolder = val;
            yield this.saveSettings();
        })));
        this.createHeader('Experimental Things', 'Not as well-tested and probably finicky');
        // Drag banners in mobile
        new obsidian.Setting(containerEl)
            .setName('Allow mobile drag')
            .setDesc(createFragment(frag => {
            frag.appendText('Allow dragging the banner on mobile devices.');
            frag.createEl('br');
            frag.createEl('b', { text: 'NOTE: ' });
            frag.appendText('App reload might be necessary');
        }))
            .addToggle(toggle => toggle
            .setValue(allowMobileDrag)
            .onChange((val) => __awaiter(this, void 0, void 0, function* () {
            this.plugin.settings.allowMobileDrag = val;
            yield this.saveSettings({ refreshViews: true });
        })));
    }
    createHeader(text, desc = null) {
        const header = this.containerEl.createDiv({ cls: 'setting-item setting-item-heading banner-setting-header' });
        header.createEl('p', { text });
        if (desc) {
            header.createEl('p', { text: desc, cls: 'banner-setting-header-description' });
        }
    }
}

const HAS_YAML_REGEX = /^-{3}(\n|\r|\r\n)((.*)(\n|\r|\r\n))*-{3}/;
class MetaManager {
    constructor(plugin) {
        this.plugin = plugin;
        this.metadata = plugin.app.metadataCache;
        this.vault = plugin.app.vault;
    }
    // Get banner metadata from a file
    getBannerData(fileOrPath) {
        var _a, _b;
        const file = (fileOrPath instanceof obsidian.TFile) ? fileOrPath : this.getFileByPath(fileOrPath);
        if (!file) {
            return;
        }
        const { banner, banner_x, banner_y } = (_b = (_a = this.metadata.getFileCache(file)) === null || _a === void 0 ? void 0 : _a.frontmatter) !== null && _b !== void 0 ? _b : {};
        return { banner, banner_x, banner_y };
    }
    // Upsert banner data into a file's frontmatter
    upsertBannerData(fileOrPath, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = (fileOrPath instanceof obsidian.TFile) ? fileOrPath : this.getFileByPath(fileOrPath);
            if (!file) {
                return;
            }
            const fields = Object.entries(data);
            const content = yield this.vault.read(file);
            const hasYaml = HAS_YAML_REGEX.test(content);
            const lines = content.split('\n');
            if (hasYaml) {
                // Search through the frontmatter to update target fields if they exist
                const start = lines.indexOf('---');
                const end = lines.indexOf('---', start + 1);
                for (let i = start + 1; i < end && fields.length; i++) {
                    const [key] = lines[i].split(': ');
                    const targetIndex = fields.findIndex(([k]) => k === key);
                    if (targetIndex === -1) {
                        continue;
                    }
                    const dataKey = key;
                    lines[i] = `${key}: ${data[dataKey]}`;
                    fields.splice(targetIndex, 1);
                }
                // Create new fields with their value if it didn't exist before
                if (fields.length) {
                    lines.splice(end, 0, this.formatYamlFields(fields));
                }
            }
            else {
                // Create frontmatter structure if none is found
                lines.unshift(stripIndents `
        ---
        ${this.formatYamlFields(fields)}
        ---
      `);
            }
            const newContent = lines.join('\n');
            yield this.vault.modify(file, newContent);
        });
    }
    removeBannerData(fileOrPath, fields = ['banner', 'banner_x', 'banner_y']) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = (fileOrPath instanceof obsidian.TFile) ? fileOrPath : this.getFileByPath(fileOrPath);
            if (!file) {
                return;
            }
            // If there's no (relevant) YAML to remove, stop here
            const { frontmatter } = this.metadata.getFileCache(file);
            console.log(frontmatter);
            const frontmatterKeys = Object.keys(frontmatter !== null && frontmatter !== void 0 ? frontmatter : {});
            if (!frontmatter || !fields.some(f => frontmatterKeys.includes(f))) {
                return;
            }
            const content = yield this.vault.read(file);
            const lines = content.split('\n');
            const { line: start } = frontmatter.position.start;
            let { line: end } = frontmatter.position.end;
            // Determine if the entire YAML should be removed or only part of it
            if (frontmatterKeys.every(f => fields.includes(f) || f === 'position')) {
                lines.splice(start, end - start + 1);
            }
            else {
                // Iterate through each YAML field-line and remove the desired ones
                for (let i = start + 1; i < end && fields.length; i++) {
                    const [key] = lines[i].split(': ');
                    const fieldIndex = fields.indexOf(key);
                    if (fieldIndex === -1) {
                        continue;
                    }
                    lines.splice(i, 1);
                    fields.splice(fieldIndex, 1);
                    i--;
                    end--;
                }
            }
            const newContent = lines.join('\n');
            yield this.vault.modify(file, newContent);
        });
    }
    // Get file based on a path string
    getFileByPath(path) {
        const file = this.vault.getAbstractFileByPath(path);
        return (file instanceof obsidian.TFile) ? file : null;
    }
    // Format into valid YAML fields
    formatYamlFields(fields) {
        return fields.sort((a, b) => a[0].localeCompare(b[0]))
            .map(([key, val]) => `${key}: ${val}`)
            .join('\n');
    }
}

const IMAGE_FORMATS = ['apng', 'avif', 'gif', 'jpg', 'jpeg', 'jpe', 'jif', 'jfif', 'png', 'webp'];
class LocalImageModal extends obsidian.FuzzySuggestModal {
    constructor(plugin, file) {
        super(plugin.app);
        this.plugin = plugin;
        this.vault = plugin.app.vault;
        this.settings = plugin.settings;
        this.metaManager = plugin.metaManager;
        const { localSuggestionsLimit } = this.settings;
        this.targetFile = file;
        this.limit = localSuggestionsLimit !== null && localSuggestionsLimit !== void 0 ? localSuggestionsLimit : INITIAL_SETTINGS.localSuggestionsLimit;
        this.setPlaceholder('Pick an image to use as a banner');
    }
    getItems() {
        const { bannersFolder } = this.settings;
        return this.vault.getFiles().filter(f => (IMAGE_FORMATS.includes(f.extension) &&
            (!bannersFolder || f.parent.path.contains(bannersFolder))));
    }
    getItemText(item) {
        return item.path;
    }
    renderSuggestion(match, el) {
        super.renderSuggestion(match, el);
        const { showPreviewInLocalModal } = this.settings;
        if (showPreviewInLocalModal) {
            const content = el.innerHTML;
            el.addClass('banner-suggestion-item');
            el.innerHTML = html `
        <p class="suggestion-text">${content}</p>
        <div class="suggestion-image-wrapper">
          <img src="${this.vault.getResourcePath(match.item)}" />
        </div>
      `;
        }
    }
    onChooseItem(image) {
        return __awaiter(this, void 0, void 0, function* () {
            this.metaManager.upsertBannerData(this.targetFile, { banner: image.path });
        });
    }
}

class BannersPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('Loading Banners...');
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
            this.workspace = this.app.workspace;
            this.vault = this.app.vault;
            this.metadataCache = this.app.metadataCache;
            this.metaManager = new MetaManager(this);
            this.loadProcessor();
            this.loadCommands();
            this.loadStyles();
            this.addSettingTab(new SettingsTab(this));
            this.refreshViews();
        });
    }
    onunload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('Unloading Banners...');
            this.unloadBanners();
            this.unloadStyles();
        });
    }
    loadProcessor() {
        this.registerMarkdownPostProcessor((el, ctx) => __awaiter(this, void 0, void 0, function* () {
            // Only process the frontmatter
            if (!el.querySelector('pre.frontmatter')) {
                return;
            }
            const { showInEmbed } = this.settings;
            const { containerEl, frontmatter } = ctx;
            const isEmbed = containerEl.parentElement.parentElement.hasClass('markdown-embed-content');
            // Stop here if no banner data is found or if a disallowed embed banner
            if (!(frontmatter === null || frontmatter === void 0 ? void 0 : frontmatter.banner) || (isEmbed && !showInEmbed)) {
                return;
            }
            const banner = document.createElement('div');
            ctx.addChild(new Banner(this, banner, el, ctx, isEmbed));
        }));
    }
    loadCommands() {
        this.addCommand({
            id: 'banners:addLocal',
            name: 'Add/Change banner with local image',
            checkCallback: (checking) => {
                const file = this.workspace.getActiveFile();
                if (checking) {
                    return !!file;
                }
                new LocalImageModal(this, file).open();
            }
        });
        this.addCommand({
            id: 'banners:addClipboard',
            name: 'Add/Change banner from clipboard',
            checkCallback: (checking) => {
                const file = this.workspace.getActiveFile();
                if (checking) {
                    return !!file;
                }
                this.pasteBanner(file);
            }
        });
        this.addCommand({
            id: 'banners:remove',
            name: 'Remove banner',
            checkCallback: (checking) => {
                var _a;
                const file = this.workspace.getActiveFile();
                if (checking) {
                    return !!file && !!((_a = this.metaManager.getBannerData(file)) === null || _a === void 0 ? void 0 : _a.banner);
                }
                this.removeBanner(file);
            }
        });
    }
    loadStyles() {
        const { embedHeight, height } = this.settings;
        document.documentElement.style.setProperty('--banner-height', `${height !== null && height !== void 0 ? height : INITIAL_SETTINGS.height}px`);
        document.documentElement.style.setProperty('--banner-embed-height', `${embedHeight !== null && embedHeight !== void 0 ? embedHeight : INITIAL_SETTINGS.embedHeight}px`);
    }
    unloadBanners() {
        this.workspace.containerEl
            .querySelectorAll('.obsidian-banner-wrapper')
            .forEach((wrapper) => {
            wrapper.querySelector('.obsidian-banner').remove();
            wrapper.removeClasses(['obsidian-banner-wrapper', 'loaded', 'error']);
        });
    }
    unloadStyles() {
        document.documentElement.style.removeProperty('--banner-height');
        document.documentElement.style.removeProperty('--banner-embed-height');
    }
    // Helper to refresh markdown views
    refreshViews() {
        this.workspace.getLeavesOfType('markdown').forEach((leaf) => {
            if (leaf.getViewState().state.mode.includes('preview')) {
                leaf.view.previewMode.rerender(true);
            }
        });
    }
    // Helper to use clipboard for banner
    pasteBanner(file) {
        return __awaiter(this, void 0, void 0, function* () {
            const clipboard = yield navigator.clipboard.readText();
            if (!isURL(clipboard)) {
                new obsidian.Notice('Your clipboard didn\'t had a valid URL! Please try again (and check the console if you wanna debug).');
                console.error({ clipboard });
            }
            else {
                this.metaManager.upsertBannerData(file, { banner: clipboard });
                new obsidian.Notice('Pasted a new banner!');
            }
        });
    }
    // Helper to remove banner
    removeBanner(file) {
        this.metaManager.removeBannerData(file);
        new obsidian.Notice(`Removed banner for ${file.name}!`);
    }
}

module.exports = BannersPlugin;
