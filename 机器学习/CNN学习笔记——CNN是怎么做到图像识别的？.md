# CNN学习笔记——CNN是怎么做到图像识别的？
* * *

——[CNN](https://so.csdn.net/so/search?q=CNN&spm=1001.2101.3001.7020)初识笔记

* * *

CNN的由来及发展（包含[图像识别](https://so.csdn.net/so/search?q=%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB&spm=1001.2101.3001.7020)的思路）
--------------------------------------------------------------------------------------------------------------------

刚接触CNN的时候，很懵。CNN？到底是什么？美国有线电视新闻网？哦，[卷积神经网络](https://so.csdn.net/so/search?q=%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&spm=1001.2101.3001.7020)（Convolutional Neural Networks）啊！为什么要叫这个名字，他又是怎么来的呢？

先思考一个问题：如果给你一张图片，你是怎么去识别图片里的内容的？一般我们应该会用到两样东西吧，那就是记忆和经验，这些东西我们也可以称之为知识，也就是对于一个图像识别任务我们必须认识过跟他同类的才能准确地识别它，这个就有意思了，和我们[有监督学习](https://so.csdn.net/so/search?q=%E6%9C%89%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0&spm=1001.2101.3001.7020)的过程不就是一样的吗，根据数据及标签训练模型，再在测试集上去测试模型预测的准确性。异曲同工之妙啊。

假设CNN整体过程就是上面所说的那样，那我们又是怎么把一个物体识别出来的呢，于人类而言，对于我们见过的物体，有的时候我们只需要看到物体的某一部分我们便可以判断出这是什么。Hubel 和 Wiesel 于 1962 年进行的一项有趣的试验证明了这件事，他们验证出大脑中的一些个体神经细胞只有在特定方向的边缘存在时才能做出反应，例如，一些神经元只对垂直边缘兴奋，另一些对水平或对角边缘兴奋，大家一起工作的时候，视觉感知便产生了，你就知道了，哦，原来这是一个西瓜。后来日本的科学家又提出了一种层级化的多层人工神经网络，即神经认知，在这个神经认知模型里，最重要的两个组成单元便是是“S细胞”和“C细胞”，两类细胞交替堆叠在一起构成了神经认知网络。其中，S细胞用于抽取局部特征，C型细胞则用于抽象和容错，S细胞在自身的感受野内最大限度地对图像中类似边缘模式的刺激做出响应，而C细胞具有更大的感受野， 它可以对图像中产生刺激的模式的空间位置进行精准地定位。再到80年代末，Yann LeCun作为贝尔实验室的研究员提出了卷积网络技术，他们构建了一个叫做LeNet-5的多层前馈神经网络，并展示了如何使用它来大幅度提高手写识别能力，这为后来卷积神经网络的发展奠定了基础，后来不断有新的模型被提出来，网络层数逐渐加深，网络图像识别的准确率也不断提升甚至超过人类（这已经是2015年的事了），直到今天这个体系还在不断的完善与发展。

回顾整个CNN的发展，不难发现，他的思想来源于生物学，实现靠数学，发展靠数据和算力，这的确是一件有趣的事情。

CNN的基本结构
--------

我们以LeNet-5为例，来看看一看CNN的基本结构组成:

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTAwNzUwMjk0NjQucG5n?x-oss-process=image/format,png)

总体来说，卷积神经网络是一种多层级的网络模型，在图像处理领域，它的输入是由多种通道构成的图像数据(如RGB的三通道)，数据在经过网络中的多重卷积、池化和激活之后，特征被提取出来，然后再通过全连接层输出，这便是网络的前向传播过程，同时，作为一种神经网络，它也会有反向传播过程：通过计算预测值与真实值之间的loss，通过反向传播，将loss逐层向前一层反馈,进而更新前向传播中的各个参数，如此往复，以训练出泛化效果更好的网络模型。

但是要深入理解卷积神经网络，我们还需要了解一些卷积神经网络中的重要概念。

感受野、滤波器、卷积
----------

什么是感受野（receptive fields）？通俗的，可以理解为在观察时某个画面时你看到的那个视野，比如“一叶蔽目”这个词，当一片叶子遮住你的眼睛时，你的感受野便只是一片叶子，看不见叶子之外的世界。在CNN中，每个神经元只感受局部的图像区域、提取局部的特征，然后在更高的层次上，不同的特征信息被汇总起来，整个图像是个什么样便也逐渐清晰起来。就好像盲人摸象，某一个盲人摸到了大象的腿，那么他的感受野就是这个像柱子一样的腿了。

那么卷积（Convolution）又是什么？卷积其实是通过一种点积形式的数学运算，将局部感受野对应范围内的特征提取出来的一个过程。记得大学时期在信号与系统中，卷积的定义如下：

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTAwODI1MjI4MDkucG5n?x-oss-process=image/format,png)

> （其中x(n)是激励信号，h(n)是单位样值响应，\*表示求卷积，延申：一个域中的卷积相当于另一个域中的乘积，例如时域中的卷积就对应于频域中的乘积，这也是傅里叶变换要说的事，扯远了。）

在CNN中，卷积的实际运算是求点积（也称内积、数量积），即矩阵或向量的对应元素相乘求和。

那么，CNN又是如何利用卷积来提取图像特征的呢？这就需要用到滤波器（filter）了。

提取不同的特征，需要多个滤波器。每种滤波器的参数不一样，表示它提取的是输入图像的不同特征。这样每种滤波器去卷积图像就得到对图像的不同特征的反映，我们称之为特征图（Feature Map）。

滤波器去卷积图像的过程有点类似中学时代老师批改英语试卷答题卡的情景，她会拿一张空白的答题卡，然后把所有正确答案对应的填涂区全部拿烟头烫穿，这样就得到了一个标准答案“滤波器”，当她拿着这张答题卡覆盖到你的答题卡上的时候，你对了多少题得多少分就是数数求和的事了，这个过程和滤波器卷积图像基本如出一辙，我们通过下面的过程可以清楚的看见：

每个过滤器可以被看成是特征标识符（ feature identifiers）。这里的特征指的是例如直边缘、颜色、曲线之类的东西。我们可以把图像都看成是由一个个特征组成的特征集合，我们拿一个个单独检测某一特征的滤波器去检测单一特征并标记，最后便可以知道图像都由哪些特征组成且他们都在图像的哪个位置。

检测单个特征时，我们是这么做的，比如说下面的曲线检测：

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTAxMjUxNTAxODEucG5n?x-oss-process=image/format,png)

图中右半部分就是你要识别的特征，他是一根曲线，对应到左边的滤波器上，可以看出，只是对应像素块上被填充了数值，这个数值可以看作是一个权重，假设他能代表颜色的深浅，如果这条曲线的下半部分全部是浅灰色，可能对应的数值就又不一样了，就像英语的选择题，有的一题一分，有的一题两分。

假如我们要识别一个老鼠图案，我们把上述这样一个曲线滤波器放在老鼠的屁股上，这样当我们拿着这样一个滤波器去卷积原始图像转化出来的矩阵时会发生什么：

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTExMDE5NDY4MzgucG5n?x-oss-process=image/format,png)

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTExMDE0MTA1NTEucG5n?x-oss-process=image/format,png)

最左边是我们的感受野，就像你答题卡上涂的一小格，转化为像素的数值表示就是中间的矩阵，最右边是我们的滤波器，就是你英语老师手上拿着的标准答案对应的那一格，好啦，卷积就是对应元素相乘做加法，我们会得到一个很大的数值，这样这个特征就被我们标记在这了，根据数值大小，我们可以认为这一块就是一条曲线，在英语试卷上就是这一题你得分了。

那么，把这个滤波器放在老鼠的头部会发生什么呢？

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTIwNzUyMjQxMjUucG5n?x-oss-process=image/format,png)

可以看到，在局部感受野内，实际像素和滤波器完美错开，卷积出来的数值等于0。我们通过这个结果可以看出，原始信号对于我们给的滤波器没有响应，从而我们知道了这一个局部感受野内没有我们要的那条曲线，但是如果我们拿一个类似老鼠圆耳朵和眼睛的滤波器来测试，这一部分就会得到一个较大的数值，我们就知道了，哦这一块是一个头啊。

那么让我们从整体上来看，如果我们要识别一张图片里的物体，我们需要怎么做呢，我们需要拿不同的滤波器去在整张图片上不断的扫描滑动，得出不同感受野与滤波器卷积之后的结果，这就是特征图（**Feature Map**）或（**Convolved Feature**” 或 “**Activation Map**”）。假如下图中滤波器代表曲线，卷积之后我们可以看出，在右对角线上整个都有曲线分布的概率就会比较大一些，这就是我们通过卷积的出来的特征信息。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvdjItN2ZjZTI5MzM1ZjliNDNiY2UxYjM3M2RhYTQwY2NjYmFfaGQud2VicA?x-oss-process=image/format,png)

步幅和填充
-----

对于上面动图展示的卷积过程，我们每次将卷积窗滑动了一个像素点，我们称每次滑动的单位为步幅（stride），这里步幅就为1，如果我们增大步幅，势必我们扫描的也就没有那么仔细，特征提取的也就不如小步幅那样精确。但是，不难看出对于一个5x5的原始图像，我们拿一个3x3卷积核（即滤波器）设置步幅为1来卷积的时候，发现最外围的那一圈都只能被扫描一次，而其他的像素点都可以被扫描两次，这样就可能导致我们漏掉图像边缘的某些重要特征，那么怎么办，我们可以在图像的外层再加上一圈来扩展图像的边界，这个我们称之为填充（padding），但是需要注意的是填充的内容不能改变图像的原始特征，所以我们不能让前来卷积的滤波器激活，一般我们需要填充的数值应该是0，这样你卷积出来的这部分结果也会是0，这样也就不影响原有特征了。

那么，针对不同的原始图像和不同大小的滤波器，我们到底需要填充多少呢？通过上面的例子可以看出：  
P = F − 1 2 P=\\frac{F-1}{2} P\=2F−1​

> 其中F是滤波器的尺寸，比如，上面F=3，那么P=1，就代表原图像周围要填充一圈0。

填充不是必需的，有的时候我们需要填充，有的时候我们不选择填充。那么通常情况下输出的特征图大小又是多少呢？  
W 2 = ( W 1 + 2 P − F + S ) S = ( W 1 + 2 P − F ) S + 1 W\_2=\\frac{(W\_1+2P-F+S)}{S}=\\frac{(W\_1+2P-F)}{S}+1 W2​\=S(W1​+2P−F+S)​\=S(W1​+2P−F)​+1  
同样的：  
H 2 = ( H 1 + 2 P − F ) S + 1 H\_2=\\frac{(H\_1+2P-F)}{S}+1 H2​\=S(H1​+2P−F)​+1  
其中W1、H1分别是卷积层的输入图像尺寸，W2、H2为卷积输出尺寸，P为填充量，S为步幅。这个公式可以不用特意去记，理解之后其实很简单。

> 例如在LeNet-5中，输入图像大小32x32，卷积核5x5，步幅1，无填充，那么第一层卷积之后输出的特征图就应该是28x28.

激活层
---

一般在卷积之后都会跟着一层激活层，激活函数会选择RELU函数，从而引入非线性特征，增强模型的表达能力。而Relu函数有可以避免sigmoid、tanh中常见的梯度消失的问题（因为其梯度只有0/1两种值，很稳定），而且还能比较好的加快收敛，提升模型训练速度，所以经常被拿来使用。

池化
--

池化（pooling ，也称下采样）是什么？池化就是通过抽象特征的过程来留住特征的同时减少参数。以最常用的最大池化（max-pooling）为例，它采用了一个过滤器（常用）和一个同样长度的步幅。然后把它应用到输入内容上，输出过滤器卷积计算的每个子区域中的最大数字。直白一点说就是把卷积出来的特征图划分成多个小方格，取每个小方格区域内最大的数作为这一区域的代表组成新的特征图。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvdjItMWE0YjJhMzc5NWQ4ZjA3M2U5MjFkNzY2ZTcwY2U2ZWNfci5qcGc?x-oss-process=image/format,png)

池化的作用主要就是在保证特征信息保留的同时减少了训练的参数量，简化了网络的复杂度，同时也实现了图像的不变性，所谓不变性即图像目标经过平移/旋转/尺度变化后是否还能取得相似的检测结果。程序每运行一轮，总能保持原有的特征。在某种程度上也扩大了感受野。

> 除了最大池化之外还有平均池化和随机池化等等。

光栅化
---

图像经过池化-下采样后，得到的是一系列的特征图，而多层感知器接受的输入是一个向量。因此需要将这些特征图中的像素依次取出，排列成一个向量。这就是光栅化。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTMxNDUzNDU2NjUucG5n?x-oss-process=image/format,png)

全连接层
----

全连接层在神经网络中一般就是起到一个分类器的作用，他将特征向量送入分类器，得到一个结果。全连接层把之前卷积出来的局部特征放到一起，比如我们找到了老鼠的屁股，找到了老鼠的眼睛胡须等等一系列特征，到了全连接层，把这些特征摆出来一看，哦这很像是一个老鼠啊，那就把它分类成老鼠吧。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvdjItY2Y4Nzg5MGViOGYyMzU4ZjIzYTFhYzc4ZWI3NjQyNTdfci5qcGc?x-oss-process=image/format,png)

训练网络
----

让我们回到最初的这张图上看一看，通过上面的学习我们已经理解了，我们是怎么去提取图像特征、并如何分类的了，网络训练的过程其实就是这个过程的具化。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3Blbm5sZWUtYWxpeXVuLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS9pbWcvaW1hZ2UtMjAyMDA2MTAwNzUwMjk0NjQucG5n?x-oss-process=image/format,png)

我们不断的卷积提取特征、前向传播暂定网络参数，反向传播更新参数以期达到在训练集上loss最小，在测试集上模型的准确率更高；这其实就是我们整个CNN甚至整个神经网络学习的大致过程。为了更好更快地实现我们“训练出一个好模型”的目标，我们越来越倾向于使用更深层的网络，当然我们还会使用到一些技巧（trick），比如，批量正则化（batch normalization）、随机失活（dropout）、图像增广（image augmentation），当然也包括我们之前说过的填充（padding）、池化（pooling），甚至我个人理解使用Relu激活函数也能算得上一种trick，填充（padding）、池化（pooling）之前已经说过了，这里再简单说一下其他几个的作用：

> 批量正则化（batch normalization）：在BN之前我们一般都只是对输入数据进行归一化，却没有在中间层进行归一化，但这样会有W一个问题，当输入数据经过矩阵乘法或各种非线性运算之后，其数据分布很可能被改变，而随着深度网络的多层运算之后，数据分布的变化将越发的不可预测。batch normalization则是对每一批数据都进行归一化，即在神经网络的训练过程中对每层的输入数据加一个标准化处理。这样保证了对每一层而言其输入数据都是归一化过的。
> 
> 实际操作上，BN就是通过一定的规范化手段，把每层神经网络任意神经元输入值的分布强行拉回到均值为0方差为1的标准正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，从而避免梯度消失问题。这样输入的小变化就会导致损失函数较大的变化（使得梯度变大，避免梯度消失问题产生），同时也  
> 让收敛速度更快，加快训练速度。

> 随机失活（dropout）：为了防止过拟合。在训练网络模型的过程中，常常容易出现过拟合的情况，特别是在训练参数很多，训练样本又很少的情况下，过拟合更容易出现。Dropout的应用就是为了防止模型的过拟合问题。Dropout通过在前向传播的过程中，让某个神经元的激活值以一定概率p停止工作（即随机暂时丢弃一些神经元），这样可以使模型的泛化能力更强，因为他不会太依赖于某些局部特征。

> 图像增广（image augmentation）：图像增广就是通过对训练图像做一系列随机改变， 产生相似但又不同的训练样本，从而扩大训练数据集的规模，降低模型对某些属性的依赖，从而提高模型的泛化能力。（常用的图像增广方法：翻转和裁剪、变化颜色及各方法叠加等）

写在最后
----

上面我们基本上把CNN在图像领域的基本应用原理说了一遍，希望我自己有一天忘记又需要用的时候，能及时的上来点开这篇文章，快速的捡回来，也希望大家相互学习指教，共享知识，共同进步。晚安。

> 参考文章：  
> [图像处理讲解-以CNN对图像进行分类为例](https://blog.csdn.net/XYlittlework/article/details/79903225)  
> [CNN（卷积神经网络）是什么](https://www.zhihu.com/question/52668301)